"use strict";(self.webpackChunkthreejs_editor_react=self.webpackChunkthreejs_editor_react||[]).push([[8579],{8579:(t,e,a)=>{a.r(e),a.d(e,{RHistStatsPainter:()=>u,RLegendPainter:()=>f,RPavePainter:()=>w,RPaveTextPainter:()=>v});var i=a(9490),s=a(1597),h=a(7243),r=a(4709),n=a(7124),d=a(3558);const l=1,c=2,o=3,g=4;class w extends h.D{async drawContent(){return this}async drawPave(){const t=this.getPadPainter().getPadRect(),e=this.getFramePainter();this.onFrame=e&&this.v7EvalAttr("onFrame",!0),this.corner=this.v7EvalAttr("corner",c);const a=this.v7EvalAttr("visible",!0),h=this.v7EvalLength("offsetX",t.width,.02),r=this.v7EvalLength("offsetY",t.height,.02),d=this.v7EvalLength("width",t.width,.3),w=this.v7EvalLength("height",t.height,.3);if(this.createG(),this.draw_g.classed("most_upper_primitives",!0),!a)return this;this.createv7AttLine("border_"),this.createv7AttFill();const f=this.onFrame?e.getFrameRect():t;let v=0,u=0;switch(this.corner){case l:v=f.x+h,u=f.y+r;break;case o:v=f.x+h,u=f.y+f.height-r-w;break;case g:v=f.x+f.width-h-d,u=f.y+f.height-r-w;break;default:v=f.x+f.width-h-d,u=f.y+r}return(0,s.bk)(this.draw_g,v,u),this.draw_g.append("svg:rect").attr("x",0).attr("width",d).attr("y",0).attr("height",w).call(this.lineatt.func).call(this.fillatt.func),this.pave_width=d,this.pave_height=w,this.drawContent().then((()=>(this.isBatchMode()||(i.settings.ContextMenu&&this.paveContextMenu&&this.draw_g.on("contextmenu",(t=>this.paveContextMenu(t))),(0,n.WJ)(this,{x:v,y:u,width:d,height:w,minwidth:20,minheight:20,redraw:t=>this.sizeChanged(t)})),this)))}sizeChanged(t){this.pave_width=t.width,this.pave_height=t.height;const e=t.x,a=t.y,i=this.getPadPainter().getPadRect(),s=this.onFrame?this.getFramePainter().getFrameRect():i,h={};let r=0,n=0;switch(this.corner){case l:r=e-s.x,n=a-s.y;break;case o:r=e-s.x,n=s.y+s.height-a-this.pave_height;break;case g:r=s.x+s.width-e-this.pave_width,n=s.y+s.height-a-this.pave_height;break;default:r=s.x+s.width-e-this.pave_width,n=a-s.y}this.v7AttrChange(h,"offsetX",r/i.width),this.v7AttrChange(h,"offsetY",n/i.height),this.v7AttrChange(h,"width",this.pave_width/i.width),this.v7AttrChange(h,"height",this.pave_height/i.height),this.v7SendAttrChanges(h,!1),this.draw_g.selectChild("rect").attr("width",this.pave_width).attr("height",this.pave_height),this.drawContent()}async redraw(){return this.drawPave()}static async draw(t,e,a){const i=new w(t,e,a,"pave");return(0,r.ensureRCanvas)(i,!1).then((()=>i.drawPave()))}}class f extends w{async drawContent(){const t=this.getObject(),e=this.v7EvalFont("text",{size:12,color:"black",align:22}),a=this.pave_width,i=this.pave_height,s=this.getPadPainter();let r=t.fEntries.length;if(t.fTitle&&r++,!r||!s)return this;const n=i/r,d=.02*a;let l=0;e.setSize(i/(1.2*r)),this.startTextDrawing(e,"font"),t.fTitle&&(this.drawText({latex:1,width:a-2*d,height:n,x:d,y:l,text:t.fTitle}),l+=n);for(let c=0;c<t.fEntries.length;++c){const e=t.fEntries[c],i=Math.round(a/4);let r=null;this.drawText({latex:1,width:.75*a-3*d,height:n,x:2*d+i,y:l,text:e.fLabel}),"custom"!==e.fDrawableId?r=s.findSnap(e.fDrawableId,!0):e.fDrawable.fIO&&(r=new h.D(this.getDom(),e.fDrawable.fIO),e.fLine&&r.createv7AttLine(),e.fFill&&r.createv7AttFill(),e.fMarker&&r.createv7AttMarker()),e.fFill&&r?.fillatt&&this.draw_g.append("svg:path").attr("d",`M${Math.round(d)},${Math.round(l+.1*n)}h${i}v${Math.round(.8*n)}h${-i}z`).call(r.fillatt.func),e.fLine&&r?.lineatt&&this.draw_g.append("svg:path").attr("d",`M${Math.round(d)},${Math.round(l+n/2)}h${i}`).call(r.lineatt.func),e.fError&&r?.lineatt&&this.draw_g.append("svg:path").attr("d",`M${Math.round(d+a/8)},${Math.round(l+.2*n)}v${Math.round(.6*n)}`).call(r.lineatt.func),e.fMarker&&r?.markeratt&&this.draw_g.append("svg:path").attr("d",r.markeratt.create(d+a/8,l+n/2)).call(r.markeratt.func),l+=n}return this.finishTextDrawing()}static async draw(t,e,a){const i=new f(t,e,a,"legend");return(0,r.ensureRCanvas)(i,!1).then((()=>i.drawPave()))}}class v extends w{drawContent(){const t=this.getObject(),e=this.v7EvalFont("text",{size:12,color:"black",align:22}),a=this.pave_width,i=this.pave_height,s=t.fText.length;if(!s)return;const h=i/s,r=.02*a;let n=0;e.setSize(i/(1.2*s)),this.startTextDrawing(e,"font");for(let d=0;d<t.fText.length;++d){const e=t.fText[d];this.drawText({latex:1,width:a-2*r,height:h,x:r,y:n,text:e}),n+=h}return this.finishTextDrawing(void 0,!0)}static async draw(t,e,a){const i=new v(t,e,a,"pavetext");return(0,r.ensureRCanvas)(i,!1).then((()=>i.drawPave()))}}class u extends w{clearStat(){this.stats_lines=[]}addText(t){this.stats_lines.push(t)}updateStatistic(t){this.stats_lines=t.lines,this.drawStatistic(this.stats_lines)}fillStatistic(){const t=this.getPadPainter();if(t?._fast_drawing)return!1;const e=this.getObject();if(void 0!==e.fLines)return this.stats_lines=e.fLines,delete e.fLines,!0;if(this.v7OfflineMode()){const t=this.getMainPainter();return!!(0,i.isFunc)(t?.fillStatistic)&&t.fillStatistic(this,i.gStyle.fOptStat,i.gStyle.fOptFit)}return void 0!==this.stats_lines}format(t,e){switch(e||(e="stat"),e){case"stat":e=i.gStyle.fStatFormat;break;case"fit":e=i.gStyle.fFitFormat;break;case"entries":if(Math.abs(t)<1e9&&Math.round(t)===t)return t.toFixed(0);e="14.7g";break;case"last":e=this.lastformat}const a=(0,s.lg)(t,e||"6.4g",!0);return this.lastformat=a[1],a[0]}async drawContent(){return this.fillStatistic()?this.drawStatistic(this.stats_lines):this}changeMask(t){const e=this.getObject(),a=1<<t;e.fShowMask&a?e.fShowMask=e.fShowMask&~a:e.fShowMask=e.fShowMask|a,this.fillStatistic()&&this.drawStatistic(this.stats_lines)}statsContextMenu(t){t.preventDefault(),t.stopPropagation(),(0,d.ES)(t,this).then((t=>{const e=this.getObject(),a=this.changeMask.bind(this);t.add("header: StatBox");for(let i=0;i<e.fEntries.length;++i)t.addchk(e.fShowMask&1<<i,e.fEntries[i],i,a);return this.fillObjectExecMenu(t)})).then((t=>t.show()))}async drawStatistic(t){if(!t)return this;const e=this.v7EvalFont("stats_text",{size:12,color:"black",align:22}),a=this.pave_width,i=this.pave_height,s=t.length;let h=0,r=0,n=0;for(let w=0;w<s;++w){const e=t[w];if(w>0&&(n=Math.max(n,e.length)),0===w||e.indexOf("|")<0)continue;0===h&&(h=w);const a=e.split("|");a.length>r&&(r=a.length)}const d=i/s,l=.02*a;let c=!1,o=this.draw_g.selectChild(".statlines");if(o.empty()?o=this.draw_g.append("svg:g").attr("class","statlines"):o.selectAll("*").remove(),e.setSize(i/(1.2*s)),this.startTextDrawing(e,"font",o),1===s)this.drawText({width:a,height:i,text:t[0],latex:1,draw_g:o});else for(let w=0;w<s;++w){const e=w*d;if(h&&w>=h){const i=t[w].split("|");for(let t=0;t<i.length;++t)this.drawText({align:"middle",x:a*t/r,y:e,latex:0,width:a/r,height:d,text:i[t],draw_g:o})}else if(t[w].indexOf("=")<0){if(0===w){c=!0;const e=Math.max(n,Math.round((a-2*l)/d/.65));t[w].length>e+5&&(t[w]=t[w].slice(0,e+2)+"...")}this.drawText({align:0===w?"middle":"start",x:l,y:e,width:a-2*l,height:d,text:t[w],draw_g:o})}else{const i=t[w].split("="),s=[];for(let t=0;t<2;++t){const h={align:0===t?"start":"end",x:l,y:e,width:a-2*l,height:d,text:i[t],draw_g:o,_expected_width:a-2*l,_args:s,post_process(t){this._args[0].ready&&this._args[1].ready&&t.scaleTextDrawing(1.05*(this._args[0].result_width&&this._args[1].result_width)/this.__expected_width,this.draw_g)}};s.push(h)}for(let t=0;t<2;++t)this.drawText(s[t])}}let g="";if(c&&(g+="M0,"+Math.round(d)+"h"+a),h>0&&r>1){for(let t=h;t<s;++t)g+="M0,"+Math.round(t*d)+"h"+a;for(let t=0;t<r-1;++t)g+="M"+Math.round(a/r*(t+1))+","+Math.round(h*d)+"V"+i}return g&&this.draw_g.append("svg:path").attr("d",g),this.finishTextDrawing(o)}async redraw(t){if(t&&(0,i.isStr)(t)&&0===t.indexOf("zoom")&&this.v7NormalMode()){const t={_typename:`${i.nsREX}RHistStatBoxBase::RRequest`,mask:this.getObject().fShowMask};this.v7SubmitRequest("stat",t,(t=>this.updateStatistic(t)))}return this.drawPave()}static async draw(t,e,a){const i=new u(t,e,a,e);return(0,r.ensureRCanvas)(i,!1).then((()=>i.drawPave()))}}}}]);
//# sourceMappingURL=8579.6a601d77.chunk.js.map