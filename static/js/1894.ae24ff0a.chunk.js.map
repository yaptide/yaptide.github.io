{"version":3,"file":"static/js/1894.ae24ff0a.chunk.js","mappings":"0NAaA,MAAMA,UAA0BC,EAAAA,GAG7BC,MAAAA,QACqBC,IAAdC,KAAKC,MAAoBD,KAAKE,cACrC,CAGAC,aAAAA,CAAcC,GACX,MAAMC,EAAI,IAAIC,EAAAA,GAAYF,GAAO,UAE5BJ,KAAKO,UAASP,KAAKO,QAAU,CAAC,GAEnCC,OAAOC,OAAOT,KAAKO,QAAS,CACxBG,KAAML,EAAEM,MAAM,QACdC,OAAQP,EAAEM,MAAM,UAChBE,MAAOR,EAAEM,MAAM,WAGnBX,KAAKc,aAAaV,EACrB,CAGA,oBAAMW,CAAeC,GACbA,IACFA,EAAO,EACPhB,KAAKiB,mBAAoB,GAG5B,MAAMC,EAAMlB,KAAKmB,aAAaC,OAAOC,IAAIrB,KAAKC,MAE9C,GAAKiB,KAAQF,GAAQE,EAAIG,IAAIC,QAK7B,OAAOC,EAAAA,EAAAA,IAAKvB,KAAKwB,SAAUN,EAAIG,IAAIL,GAAOE,EAAId,IAAIY,IAAOS,MAAKC,IACvDA,IACDA,EAAEC,UAAY3B,KAAK4B,OACnBF,EAAEG,QAAU7B,KAAKC,MAEbD,KAAKe,eAAeC,EAAK,aATzBhB,KAAKiB,iBAWlB,CAGAa,eAAAA,GACG,IAAK9B,KAAKO,QAAS,OAEnB,MAAMwB,EAAK/B,KAAKmB,YAEhB,GAAInB,KAAKO,QAAQM,aAEPb,KAAKC,UAIf,GAAID,KAAKgC,qBAAsB,QACrBhC,KAAKgC,qBAGZ,MAAMC,EAAKjC,KAAKkC,gBAChB,IAAKD,EAGF,mBADOjC,KAAKC,KAKfD,KAAKe,iBAAiBU,MAAK,KAExBQ,EAAGE,iBAAgBT,GAAeA,EAAEC,YAAc3B,KAAK4B,QAAYF,EAAEG,UAAY7B,KAAKC,OAEtFD,KAAK8B,iBAAiB,GAE5B,MAAO,GAAI9B,KAAKoC,gBACbC,aAAarC,KAAKoC,wBACXpC,KAAKoC,gBAEZpC,KAAKgC,sBAAuB,EAE5BM,uBAAsB,IAAMtC,KAAK8B,wBAC7B,CACJ,IAAIS,EAAYC,KAAKC,IAAIV,EAAGW,WAAY,IAExC,KAAM1C,KAAKC,KAAO8B,EAAGX,OAAOC,IAAIC,OAAQ,CACrC,IAAItB,KAAKO,QAAQK,OAKd,mBADOZ,KAAKC,KAHZD,KAAKC,KAAO,EACZsC,EAAYC,KAAKC,IAAI,IAAM,EAAEF,EAKnC,CAEAvC,KAAKoC,gBAAkBO,YAAW,IAAM3C,KAAK8B,mBAAmBS,EACnE,CACH,CAGArC,YAAAA,GAGG,OAFAF,KAAKC,KAAO,EAELD,KAAKe,iBAAiBU,MAAK,KAC/BzB,KAAK8B,kBACE9B,OAEb,CAGA,iBAAauB,CAAKqB,EAAKb,EAAI3B,GACxB,IAAK2B,EAAGc,OAEN,OADAC,QAAQC,MAAM,8BACP,KAGT,MAAMC,EAAU,IAAIpD,EAAkBgD,EAAKb,GAE3C,GAAIiB,EAAQC,iBAET,OADAH,QAAQC,MAAM,qDACP,KAKV,GAFAC,EAAQ7C,cAAcC,IAEjB2B,EAAGc,OAAOK,QAAUnB,EAAGmB,OAAQ,CACjC,MAAM7B,EAAMU,EAAGmB,OAAOC,MAAM,KAC5BpB,EAAGc,OAAOK,OAAS7B,EAAI,GACnBA,EAAI,KAAIU,EAAGc,OAAOO,OAAOF,OAAS7B,EAAI,IACtCA,EAAI,KAAIU,EAAGc,OAAOQ,OAAOH,OAAS7B,EAAI,GAC7C,CAIA,OAFA2B,EAAQpB,OAAS,UAAY0B,EAAAA,UAAUC,aAEhCC,EAAAA,EAAWjC,KAAKqB,EAAKb,EAAGc,OAAQ,IAAIpB,MAAK,KAC7CuB,EAAQS,qBACDT,EAAQ9C,iBAErB,E","sources":["../node_modules/jsroot/modules/hist/TGraphTimePainter.mjs"],"sourcesContent":["import { internals } from '../core.mjs';\nimport { DrawOptions } from '../base/BasePainter.mjs';\nimport { ObjectPainter } from '../base/ObjectPainter.mjs';\nimport { TH1Painter } from '../hist2d/TH1Painter.mjs';\nimport { draw } from '../draw.mjs';\n\n\n/**\n * @summary Painter for TGraphTime object\n *\n * @private\n */\n\nclass TGraphTimePainter extends ObjectPainter {\n\n   /** @summary Redraw object */\n   redraw() {\n      if (this.step === undefined) this.startDrawing();\n   }\n\n   /** @summary Decode drawing options */\n   decodeOptions(opt) {\n      const d = new DrawOptions(opt || 'REPEAT');\n\n      if (!this.options) this.options = {};\n\n      Object.assign(this.options, {\n          once: d.check('ONCE'),\n          repeat: d.check('REPEAT'),\n          first: d.check('FIRST')\n      });\n\n      this.storeDrawOpt(opt);\n   }\n\n   /** @summary Draw primitives */\n   async drawPrimitives(indx) {\n      if (!indx) {\n         indx = 0;\n         this._doing_primitives = true;\n      }\n\n      const lst = this.getObject()?.fSteps.arr[this.step];\n\n      if (!lst || (indx >= lst.arr.length)) {\n         delete this._doing_primitives;\n         return;\n      }\n\n      return draw(this.getDom(), lst.arr[indx], lst.opt[indx]).then(p => {\n         if (p) {\n            p.$grtimeid = this.selfid; // indicator that painter created by ourself\n            p.$grstep = this.step; // remember step\n         }\n         return this.drawPrimitives(indx+1);\n      });\n   }\n\n   /** @summary Continue drawing */\n   continueDrawing() {\n      if (!this.options) return;\n\n      const gr = this.getObject();\n\n      if (this.options.first) {\n         // draw only single frame, cancel all others\n         delete this.step;\n         return;\n      }\n\n      if (this.wait_animation_frame) {\n         delete this.wait_animation_frame;\n\n         // clear pad\n         const pp = this.getPadPainter();\n         if (!pp) {\n            // most probably, pad is cleared\n            delete this.step;\n            return;\n         }\n\n         // draw ptrimitives again\n         this.drawPrimitives().then(() => {\n            // clear primitives produced by previous drawing to avoid flicking\n            pp.cleanPrimitives(p => { return (p.$grtimeid === this.selfid) && (p.$grstep !== this.step); });\n\n            this.continueDrawing();\n         });\n      } else if (this.running_timeout) {\n         clearTimeout(this.running_timeout);\n         delete this.running_timeout;\n\n         this.wait_animation_frame = true;\n         // use animation frame to disable update in inactive form\n         requestAnimationFrame(() => this.continueDrawing());\n      } else {\n         let sleeptime = Math.max(gr.fSleepTime, 10);\n\n         if (++this.step > gr.fSteps.arr.length) {\n            if (this.options.repeat) {\n               this.step = 0; // start again\n               sleeptime = Math.max(5000, 5*sleeptime); // increase sleep time\n            } else {\n               delete this.step;    // clear indicator that animation running\n               return;\n            }\n         }\n\n         this.running_timeout = setTimeout(() => this.continueDrawing(), sleeptime);\n      }\n   }\n\n   /** @ummary Start drawing of graph time */\n   startDrawing() {\n      this.step = 0;\n\n      return this.drawPrimitives().then(() => {\n         this.continueDrawing();\n         return this;\n      });\n   }\n\n   /** @summary Draw TGraphTime object */\n   static async draw(dom, gr, opt) {\n      if (!gr.fFrame) {\n        console.error('Frame histogram not exists');\n        return null;\n      }\n\n      const painter = new TGraphTimePainter(dom, gr);\n\n      if (painter.getMainPainter()) {\n         console.error('Cannot draw graph time on top of other histograms');\n         return null;\n      }\n\n      painter.decodeOptions(opt);\n\n      if (!gr.fFrame.fTitle && gr.fTitle) {\n         const arr = gr.fTitle.split(';');\n         gr.fFrame.fTitle = arr[0];\n         if (arr[1]) gr.fFrame.fXaxis.fTitle = arr[1];\n         if (arr[2]) gr.fFrame.fYaxis.fTitle = arr[2];\n      }\n\n      painter.selfid = 'grtime_' + internals.id_counter++; // use to identify primitives which should be clean\n\n      return TH1Painter.draw(dom, gr.fFrame, '').then(() => {\n         painter.addToPadPrimitives();\n         return painter.startDrawing();\n      });\n   }\n\n} // class TGraphTimePainter\n\nexport { TGraphTimePainter };\n"],"names":["TGraphTimePainter","ObjectPainter","redraw","undefined","this","step","startDrawing","decodeOptions","opt","d","DrawOptions","options","Object","assign","once","check","repeat","first","storeDrawOpt","drawPrimitives","indx","_doing_primitives","lst","getObject","fSteps","arr","length","draw","getDom","then","p","$grtimeid","selfid","$grstep","continueDrawing","gr","wait_animation_frame","pp","getPadPainter","cleanPrimitives","running_timeout","clearTimeout","requestAnimationFrame","sleeptime","Math","max","fSleepTime","setTimeout","dom","fFrame","console","error","painter","getMainPainter","fTitle","split","fXaxis","fYaxis","internals","id_counter","TH1Painter","addToPadPrimitives"],"sourceRoot":""}